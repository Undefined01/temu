From 5fb6898eb099974f2df3bfab9d508f25b8043dc3 Mon Sep 17 00:00:00 2001
From: Undefined01 <amoscr@163.com>
Date: Mon, 22 Sep 2025 23:06:01 +0800
Subject: [PATCH 2/2] Port for rtthread

---
 am/src/nemu/isa/riscv/cte.c   | 13 +++++++++---
 am/src/nemu/isa/riscv/cte64.c | 40 ++++++++++++++++++-----------------
 apps/yield-os/Makefile        |  3 +++
 apps/yield-os/yield-os.c      | 31 +++++++++++++++++++++++++++
 libs/klib/include/klib.h      |  2 +-
 5 files changed, 66 insertions(+), 23 deletions(-)
 create mode 100644 apps/yield-os/Makefile
 create mode 100644 apps/yield-os/yield-os.c

diff --git a/am/src/nemu/isa/riscv/cte.c b/am/src/nemu/isa/riscv/cte.c
index b660feff..d7e31153 100644
--- a/am/src/nemu/isa/riscv/cte.c
+++ b/am/src/nemu/isa/riscv/cte.c
@@ -102,6 +102,7 @@ _Context* __am_irq_SECALL_handler(_Event *ev, _Context *c) {
   return c;
 }
 
+static _Context* (*global_irq_handler)(_Event ev, _Context *c) = NULL;
 
 _Context* __am_irq_handle(_Context *c) {
   __am_get_cur_as(c);
@@ -121,9 +122,13 @@ _Context* __am_irq_handle(_Context *c) {
 
   __am_switch(c);
 
-#if __riscv_xlen == 64
-  asm volatile("fence.i");
-#endif
+  if (global_irq_handler != NULL) {
+    c = global_irq_handler(ev, c);
+  }
+
+// #if __riscv_xlen == 64
+//   asm volatile("fence.i");
+// #endif
 
   return c;
 }
@@ -211,6 +216,8 @@ int _cte_init(_Context *(*handler)(_Event ev, _Context *ctx)) {
 
   asm volatile("csrw sscratch, zero");
 
+  global_irq_handler = handler;
+
   // cte init handler has no effect for now
 
 #if __riscv_xlen == 64
diff --git a/am/src/nemu/isa/riscv/cte64.c b/am/src/nemu/isa/riscv/cte64.c
index 737341c7..4c713f4f 100644
--- a/am/src/nemu/isa/riscv/cte64.c
+++ b/am/src/nemu/isa/riscv/cte64.c
@@ -5,7 +5,7 @@ extern void __am_timervec(void);
 
 static void init_machine_exception() {
   // set M-mode exception entry
-  asm volatile("csrw mtvec, %0" : : "r"(__am_timervec));
+  asm volatile("csrw stvec, %0" : : "r"(__am_timervec));
 }
 
 int g_config_disable_timer = 0; // dirty hack of __am_init_cte64(), to be refactored
@@ -23,14 +23,14 @@ static void init_eip() {
 
 void __am_init_cte64() {
   // set delegation (do not deleg illegal instruction exception)
-  asm volatile("csrw mideleg, %0" : : "r"(0xffff));
-  asm volatile("csrw medeleg, %0" : : "r"(0xfffb));
+  // asm volatile("csrw mideleg, %0" : : "r"(0xffff));
+  // asm volatile("csrw medeleg, %0" : : "r"(0xfffb));
 
   // set PMP to access all memory in S-mode
   // asm volatile("csrw pmpaddr8, %0" : : "r"(-1));
   // asm volatile("csrw pmpcfg2, %0" : : "r"(31));
   
-  init_pmp();
+  // init_pmp();
 #if defined(__ARCH_RISCV64_NOOP) || defined(__ARCH_RISCV32_NOOP) || defined(__ARCH_RISCV64_XS)
   // protect 0x90000000 + 0x10000 for test purpose
   printf("enable_pmp\n");
@@ -53,20 +53,22 @@ void __am_init_cte64() {
   // invalid arch
 #endif
 
-  init_machine_exception();
-  init_timer();
-  if(!g_config_disable_timer){
-    enable_timer();
-  }
-  init_eip();
+  // init_machine_exception();
+  (void)init_machine_exception;
+  // init_timer();
+  // if(!g_config_disable_timer){
+  //   enable_timer();
+  // }
+  // init_eip();
+  (void)init_eip;
 
-  // enter S-mode
-  uintptr_t status = MSTATUS_SPP(MODE_S);
-  extern char _here;
-  asm volatile(
-    "csrw sstatus, %0;"
-    "csrw sepc, %1;"
-    "sret;"
-    "_here:"
-    : : "r"(status), "r"(&_here));
+  // // enter S-mode
+  // uintptr_t status = MSTATUS_SPP(MODE_S);
+  // extern char _here;
+  // asm volatile(
+  //   "csrw sstatus, %0;"
+  //   "csrw sepc, %1;"
+  //   "sret;"
+  //   "_here:"
+  //   : : "r"(status), "r"(&_here));
 }
diff --git a/apps/yield-os/Makefile b/apps/yield-os/Makefile
new file mode 100644
index 00000000..dbb6cdf8
--- /dev/null
+++ b/apps/yield-os/Makefile
@@ -0,0 +1,3 @@
+NAME = yield-os
+SRCS = yield-os.c
+include $(AM_HOME)/Makefile.app
diff --git a/apps/yield-os/yield-os.c b/apps/yield-os/yield-os.c
new file mode 100644
index 00000000..87acd8be
--- /dev/null
+++ b/apps/yield-os/yield-os.c
@@ -0,0 +1,31 @@
+#include <am.h>
+#include <klib-macros.h>
+
+#define STACK_SIZE (4096 * 8)
+typedef union {
+  uint8_t stack[STACK_SIZE];
+  struct { _Context *cp; };
+} PCB;
+static PCB pcb[2], pcb_boot, *current = &pcb_boot;
+
+static void f(void *arg) {
+  while (1) {
+    _putc("?AB"[(uintptr_t)arg > 2 ? 0 : (uintptr_t)arg]);
+    for (int volatile i = 0; i < 100000; i++) ;
+    _yield();
+  }
+}
+
+static _Context *schedule(_Event ev, _Context *prev) {
+  current->cp = prev;
+  current = (current == &pcb[0] ? &pcb[1] : &pcb[0]);
+  return current->cp;
+}
+
+int main() {
+  _cte_init(schedule);
+  pcb[0].cp = _kcontext((_Area) { pcb[0].stack, &pcb[0] + 1 }, f, (void *)1L);
+  pcb[1].cp = _kcontext((_Area) { pcb[1].stack, &pcb[1] + 1 }, f, (void *)2L);
+  _yield();
+  panic("Should not reach here!");
+}
diff --git a/libs/klib/include/klib.h b/libs/klib/include/klib.h
index d0cb0a6e..51661e5c 100644
--- a/libs/klib/include/klib.h
+++ b/libs/klib/include/klib.h
@@ -62,7 +62,7 @@ char *strrchr(const char *s, int c);
 // stdlib.h
 int atoi(const char* nptr);
 int abs(int x);
-unsigned long time();
+long time();
 void srand(unsigned int seed);
 int rand();
 void *malloc(size_t size);
-- 
2.30.2

